#! /usr/bin/env node

'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const util = require('util');
const program = require('commander');
const tplinkCrypto = require('tplink-smarthome-crypto');

var _require = require('./');

const Client = _require.Client,
      ResponseError = _require.ResponseError;


let logLevel;
let client;

let outputError = function outputError(err) {
  if (err instanceof ResponseError) {
    console.log(err.response);
  } else {
    console.error(err);
  }
};

let search = function search(sysInfo, timeout, params) {
  try {
    console.log('Searching...');

    let commandParams = Object.assign({}, { discoveryInterval: 2000, discoveryTimeout: timeout }, params); // {discoveryInterval: 2000, discoveryTimeout: timeout, ...params};
    console.log(`startDiscovery(${util.inspect(commandParams)})`);
    client.startDiscovery(commandParams).on('device-new', device => {
      console.log(`${device.model} ${device.deviceType} ${device.type} ${device.host} ${device.port} ${device.macNormalized} ${device.deviceId} ${device.alias}`);
      if (sysInfo) {
        console.dir(device.sysInfo, { colors: program.color === 'on', depth: 10 });
      }
    });
  } catch (err) {
    outputError(err);
  }
};

let send = (() => {
  var _ref = _asyncToGenerator(function* (host, port, payload) {
    try {
      console.log(`Sending to ${host}:${port}...`);
      let data = yield client.send(payload, host, port);
      console.log('response:');
      console.dir(data, { colors: program.color === 'on', depth: 10 });
    } catch (err) {
      outputError(err);
    }
  });

  return function send(_x, _x2, _x3) {
    return _ref.apply(this, arguments);
  };
})();

let sendCommand = (() => {
  var _ref2 = _asyncToGenerator(function* (host, port, payload) {
    try {
      console.log(`Sending to ${host}:${port}...`);
      let device = yield client.getDevice({ host, port });
      let results = yield device.sendCommand(payload);
      console.log('response:');
      console.dir(results, { colors: program.color === 'on', depth: 10 });
    } catch (err) {
      outputError(err);
    }
  });

  return function sendCommand(_x4, _x5, _x6) {
    return _ref2.apply(this, arguments);
  };
})();

let sendCommandDynamic = (() => {
  var _ref3 = _asyncToGenerator(function* (host, port, command, commandParams = []) {
    try {
      console.log(`Sending ${command} command to ${host}:${port}...`);
      let device = yield client.getDevice({ host, port });
      let results = yield device[command](...commandParams);
      console.log('response:');
      console.dir(results, { colors: program.color === 'on', depth: 10 });
    } catch (err) {
      outputError(err);
    }
  });

  return function sendCommandDynamic(_x7, _x8, _x9) {
    return _ref3.apply(this, arguments);
  };
})();

let details = (() => {
  var _ref4 = _asyncToGenerator(function* (host, port, timeout) {
    try {
      console.log(`Getting details from ${host}:${port}...`);
      let device = yield client.getDevice({ host, port });
      console.dir({
        alias: device.alias,
        deviceId: device.deviceId,
        description: device.description,
        model: device.model,
        deviceType: device.deviceType,
        type: device.type,
        softwareVersion: device.softwareVersion,
        hardwareVersion: device.hardwareVersion,
        mac: device.mac
      }, { colors: program.color === 'on', depth: 10 });
    } catch (err) {
      outputError(err);
    }
  });

  return function details(_x10, _x11, _x12) {
    return _ref4.apply(this, arguments);
  };
})();

let blink = function blink(host, port, times, rate, timeout) {
  console.log(`Sending blink commands to ${host}:${port}...`);
  client.getDevice({ host, port }).then(device => {
    return device.blink(times, rate).then(() => {
      console.log('Blinking complete');
    });
  }).catch(reason => {
    outputError(reason);
  });
};

let toInt = s => {
  return parseInt(s);
};

let setupClient = function setupClient() {
  let defaultSendOptions = {};
  if (program.udp) defaultSendOptions.transport = 'udp';
  if (program.timeout) defaultSendOptions.timeout = program.timeout;
  let client = new Client({ logLevel, defaultSendOptions });
  return client;
};

let setParamTypes = function setParamTypes(params, types) {
  if (params && params.length > 0 && types && types.length > 0) {
    return Array.from(params).map((el, i) => {
      if (types[i] === 'number') {
        return +el;
      }
      return el;
    });
  }
  return params;
};

program.option('-D, --debug', 'turn on debug level logging', () => {
  logLevel = 'debug';
}).option('-t, --timeout <ms>', 'timeout (ms)', toInt, 5000).option('-u, --udp', 'send via UDP').option('-c, --color [on]', 'output will be styled with ANSI color codes', 'on');

program.command('search [params]').description('Search for devices').option('-s, --sysinfo', 'output sysInfo').action(function (params, options) {
  client = setupClient();
  if (params) {
    console.dir(params);
    params = JSON.parse(params);
  }
  search(options.sysinfo, program.timeout, params);
});

program.command('send <host> <payload>').description('Send payload to device (using Client.send)').action(function (host, payload, options) {
  client = setupClient();

  var _host$split = host.split(':'),
      _host$split2 = _slicedToArray(_host$split, 2);

  let hostOnly = _host$split2[0],
      port = _host$split2[1];

  send(hostOnly, port, payload);
});

program.command('sendCommand <host> <payload>').description('Send payload to device (using Device#sendCommand)').action(function (host, payload, options) {
  client = setupClient();

  var _host$split3 = host.split(':'),
      _host$split4 = _slicedToArray(_host$split3, 2);

  let hostOnly = _host$split4[0],
      port = _host$split4[1];

  sendCommand(hostOnly, port, payload);
});

program.command('details <host>').action(function (host, options) {
  client = setupClient();

  var _host$split5 = host.split(':'),
      _host$split6 = _slicedToArray(_host$split5, 2);

  let hostOnly = _host$split6[0],
      port = _host$split6[1];

  details(hostOnly, port, program.timeout);
});

program.command('blink <host> [times] [rate]').action(function (host, times = 5, rate = 500, options) {
  client = setupClient();

  var _host$split7 = host.split(':'),
      _host$split8 = _slicedToArray(_host$split7, 2);

  let hostOnly = _host$split8[0],
      port = _host$split8[1];

  blink(hostOnly, port, times, rate);
});

['getSysInfo', 'getInfo', 'setAlias', 'getModel', { fnName: 'setLocation', paramTypes: ['number', 'number'] }, { fnName: 'reboot', paramTypes: ['number'] }, { fnName: 'reset', paramTypes: ['number'] }].forEach(command => {
  let commandName;
  let paramTypes;
  if (command.fnName) {
    commandName = command.fnName;
    paramTypes = command.paramTypes;
  } else {
    commandName = command;
  }
  program.command(`${commandName} <host> [params]`).description(`Send ${commandName} to device (using Device#${commandName})`).option('-t, --timeout [timeout]', 'timeout (ms)', toInt, 5000).action(function (host, params, options) {
    client = setupClient();

    var _host$split9 = host.split(':'),
        _host$split10 = _slicedToArray(_host$split9, 2);

    let hostOnly = _host$split10[0],
        port = _host$split10[1];

    sendCommandDynamic(hostOnly, port, commandName, setParamTypes(params, paramTypes));
  });
});

program.command('encrypt <outputEncoding> <input> [firstKey=0xAB]').action(function (outputEncoding, input, firstKey = 0xAB) {
  let outputBuf = tplinkCrypto.encrypt(input, firstKey);
  console.log(outputBuf.toString(outputEncoding));
});
program.command('encryptWithHeader <outputEncoding> <input> [firstKey=0xAB]').action(function (outputEncoding, input, firstKey = 0xAB) {
  let outputBuf = tplinkCrypto.encryptWithHeader(input, firstKey);
  console.log(outputBuf.toString(outputEncoding));
});
program.command('decrypt <inputEncoding> <input> [firstKey=0xAB]').action(function (inputEncoding, input, firstKey = 0xAB) {
  let inputBuf = Buffer.from(input, inputEncoding);
  let outputBuf = tplinkCrypto.decrypt(inputBuf, firstKey);
  console.log(outputBuf.toString());
});
program.command('decryptWithHeader <inputEncoding> <input> [firstKey=0xAB]').action(function (inputEncoding, input, firstKey = 0xAB) {
  let inputBuf = Buffer.from(input, inputEncoding);
  let outputBuf = tplinkCrypto.decryptWithHeader(inputBuf, firstKey);
  console.log(outputBuf.toString());
});

program.parse(process.argv);

if (!process.argv.slice(2).length) {
  program.outputHelp();
}